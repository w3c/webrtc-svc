<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8">
  <link href="webrtc.css" rel="stylesheet">
  <title>Scalable Video Coding (SVC) Extension for WebRTC</title>
  <script class="remove" src="https://www.w3.org/Tools/respec/respec-w3c"></script>
  <script class="remove" src="svc-respec-config.js" ></script>
</head>
<body>
  <section id="abstract">
    <p>
      This document defines a set of ECMAScript APIs in WebIDL to extend the WebRTC 1.0 API
      to enable user agents to support scalable video coding (SVC).
    </p>
  </section>
  <section id="sotd">
    <p>
      The API is based on preliminary work done in the W3C ORTC Community Group.
    </p>
  </section>
  <section class="informative" id="intro">
    <h2>Introduction</h2>
    <p>
      This specification extends the WebRTC specification [[WEBRTC]] to
      enable configuration of encoding parameters, as well as the
      discovery of Scalable Video Coding (SVC) encoder capabilities. The
      discovery of decoder capabilities and configuration of decoding
      parameters is not supported.
    </p>
    <p>
      Since this specification does not change the behavior of WebRTC
      objects and methods, restrictions relating to Offer/Answer negotiation and
      encoding parameters remain, as described in [[WEBRTC]] Section 5.2:
      "{{RTCRtpSender/setParameters()}} does not cause SDP renegotiation and can
      only be used to change what the media stack is sending or receiving within the
      envelope negotiated by Offer/Answer."
    </p>
    <p>
      The configuration of SVC-capable codecs implemented in browsers fits within this
      restriction. Codecs such as VP8 [[?RFC6386]], VP9 [[?VP9]] and AV1 [[?AV1]] do not
      negotiate SVC support within Offer/Answer, enabling encoding parameters to be used
      for SVC configuration.
    </p>
  </section>
  <section id="conformance">
    <p>
      This specification defines conformance criteria that apply to a single
      product: the user agent that implements the interfaces that it
      contains.
    </p>
    <p>
      Conformance requirements phrased as algorithms or specific steps may be
      implemented in any manner, so long as the end result is equivalent. In
      particular, the algorithms defined in this specification are intended to be
      easy to follow, and not intended to be performant.
    </p>
    <p>
      Implementations that use ECMAScript to implement the APIs defined in
      this specification MUST implement them in a manner consistent with the
      ECMAScript Bindings defined in the Web IDL specification [[WEBIDL]], as
      this specification uses that specification and terminology.
    </p>
  </section>
  <section>
    <h2>Terminology</h2>
      <p>
        The term "simulcast envelope" is defined in [[!WEBRTC]] Section 5.4.1. 
      </p>
      <p>
        This specification references objects, methods, internal slots
        and dictionaries defined in [[!WEBRTC]].
      </p>
      <p>
        For Scalable Video Coding (SVC), the terms "single-session transmission"
        (<dfn>SST</dfn>) and "multi-session transmission" (<dfn>MST</dfn>) are
        defined in [[?RFC6190]]. This specification only supports <a>SST</a> but
        not <a>MST</a>.
      </p>
      <p>
        The term "Single Real-time Transport Protocol stream Single Transport"
        (<dfn>SRST</dfn>), defined in [[RFC7656]] Section 3.7, refers to SVC
        implementations that transmit all layers within a single transport,
        using a single Real-time Transport Protocol (RTP) stream and
        synchronization source (SSRC). The term "Multiple RTP stream Single
        Transport" (<dfn>MRST</dfn>), also defined in [[RFC7656]] Section 3.7,
        refers to implementations that transmit all layers within a single
        transport, using multiple RTP streams with a distinct SSRC for each layer. 
        This specification only supports <a>SRST</a>, not <a>MRST</a>. Codecs
        with RTP payload specifications supporting <a>SRST</a> include VP8
        [[?RFC7741]], VP9 [[?VP9-PAYLOAD]], AV1 [[?AV1-RTP]] and H.264/SVC
        [[?RFC6190]].
      </p>
      <p>
        The term "S mode" refers to a scalability mode in which multiple
        encodings are sent on the same SSRC. This includes the [="S2T1"=], [="S2T1h"=],
        [="S2T2"=], [="S2T2h"=], [="S2T3"=], [="S2T3h"=], [="S3T1"=], [="S3T1h"=], [="S3T2"=], [="S3T2h"=],
        [="S3T3"=] and [="S3T3h"=] {{RTCRtpEncodingParameters/scalabilityMode}} values.
      </p>
      <p>
        The term <dfn data-lt="SFM" data-noexport>Selective Forwarding Middlebox</dfn>
        (SFM) is defined in Section 3.7 of [[RFC7667]].
      </p>
      <p>
        <dfn data-noexport data-idl data-dfn-for="VideoConfiguration">spatialScalability</dfn>
        is an addition to {{VideoConfiguration}} in the
        <a href="https://www.w3.org/TR/media-capabilities/#dom-videoconfiguration-spatialscalability">Media Capabilities API</a>.
      </p>
  </section>
  <section id="configuration">
    <h2>Configuration</h2>
      <p>
        This specification enables the configuration of encoding parameters for SVC 
        by extending the {{RTCRtpEncodingParameters}} dictionary. 
      </p>
    <section id="rtcrtpencodingparameters">
      <h3>{{RTCRtpEncodingParameters}} Dictionary Extensions</h3>
      <div>
        <pre class="idl">partial dictionary RTCRtpEncodingParameters {
             DOMString scalabilityMode;
};</pre>
        <section>
          <h2>Dictionary {{RTCRtpEncodingParameters}} Members</h2>
          <dl data-link-for="RTCRtpEncodingParameters" data-dfn-for=
          "RTCRtpEncodingParameters" class="dictionary-members">
            <dt><dfn data-idl>scalabilityMode</dfn> of type {{DOMString}}</dt>
            <dd>
              <p>
                A case-sensitive identifier of the scalability mode to be
                used for this stream. Scalability modes are defined in
                Section 6.
              </p>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <section id="behavior">
      <h2>Behavior</h2>
        <p>
          [[!WEBRTC]] describes error handling in {{RTCPeerConnection/addTransceiver()}}
          (Section 5.1) and {{RTCRtpSender/setParameters()}} (Section 5.2),
          including use of {{RTCError}} to indicate a
          {{RTCErrorDetailType/"hardware-encoder-error"}}
          due to an unsupported encoding parameter, as well as other errors.
          Implementations utilize {{RTCError}} and other errors
          in the prescribed manner when an invalid
          {{RTCRtpEncodingParameters/scalabilityMode}} value is provided to 
          {{RTCRtpSender/setParameters()}} or {{RTCPeerConnection/addTransceiver()}}.
        </p>
      <section id="addTransceiver">
       <h3>{{RTCPeerConnection/addTransceiver()}}</h3>
         <p>
           [[!WEBRTC]] Section 5.1 describes validation of
           {{RTCRtpTransceiverInit/sendEncodings}} within
           {{RTCPeerConnection/addTransceiver()}}. To validate
           {{RTCRtpEncodingParameters/scalabilityMode}}, add
           the following validation steps after step 3 (within step 8):
           <ol>
             <li>
               If <var>sendEncodings</var> contains any encoding whose
               {{RTCRtpEncodingParameters/scalabilityMode}} value is 
               not supported by any codec in
               {{RTCRtpSender.getCapabilities(kind)}}.<code>codecs</code>,
               [= exception/throw =] an {{OperationError}}.
             </li>
             <li>
               If the number of {{RTCRtpEncodingParameters}} stored in
               <var>sendEncodings</var> is more than 1, and
               <var>sendEncodings</var> contains any encoding whose
               {{RTCRtpEncodingParameters/scalabilityMode}} value
               represents an "S mode" [= exception/throw =] an
               {{OperationError}}.
             </li>
           </ol>
         </p>
         <p>
           When the {{RTCPeerConnection/addTransceiver()}} and
           {{RTCRtpTransceiver/setCodecPreferences()}} methods are called
           prior to conclusion of the Offer/Answer negotiation, the negotiated
           codec and its capabilities may not be known. In this situation the
           {{RTCRtpEncodingParameters/scalabilityMode}} values configured
           in {{RTCRtpTransceiverInit/sendEncodings}} may not be supported
           by the eventually negotiated codec. However, an error will only result
           if the requested {{RTCRtpEncodingParameters/scalabilityMode}} value is
           invalid for any supported codec, or if mixed simulcast transport is requested.
        </p>
        <p>
          So as to ensure that the desired {{RTCRtpEncodingParameters/scalabilityMode}}
          values can be applied, {{RTCRtpTransceiver/setCodecPreferences()}} can be
          used to prefer or only include codecs supporting the desired configuration.
          For example, if temporal scalability is desired along with spatial simulcast,
          when {{RTCPeerConnection/addTransceiver()}} is called,
          {{RTCRtpTransceiverInit/sendEncodings}} can be configured to send multiple
          simulcast streams with different resolutions, with each stream
          utilizing temporal scalability. If only the VP8, VP9 and AV1 codec implementations
          support temporal scalability, {{RTCRtpTransceiver/setCodecPreferences()}}
          can be used to remove the H.264/AVC codec from the Offer, improving the
          chances that a codec supporting temporal scalability is negotiated.
        </p>
        <p>
          When {{RTCRtpTransceiverInit/sendEncodings}} is used to
          request the sending of multiple simulcast streams using
          {{RTCPeerConnection/addTransceiver()}}, an "S mode" cannot
          be requested. The browser may only be configured to send
          simulcast encodings with multiple SSRCs and RIDs, or
          alternatively, to send all simulcast encodings on a single
          RTP stream. Simultaneously using both simulcast transport
          techniques is not permitted. 
        </p>
      </section>
      <section id="setparameters">
       <h3>{{RTCRtpSender/setParameters()}}</h3>
         <p>
           [[!WEBRTC]] Section 5.2 describes validation of <var>parameters</var>
           within {{RTCRtpSender/setParameters()}}. Add the following to the 
           conditions under which the operation causes a promise rejected
           with an {{InvalidModificationError}} (step 4 within step 6):
           <ol>
             <li>
               Before initial negotiation has concluded,
               <var>encodings</var> contains any encoding whose
               {{RTCRtpEncodingParameters/scalabilityMode}} value is 
               not supported by any codec in
               {{RTCRtpSender.getCapabilities(kind)}}.<code>codecs</code>. 
             </li>
             <li>
               After initial negotiation has concluded,
               <var>encodings</var> contains an encoding whose
               {{RTCRtpEncodingParameters/scalabilityMode}} value is
               not supported by the most preferred codec.
             </li>
             <li>
               <var>N</var> is greater than 1, and <var>encodings</var>
               contains an encoding whose
               {{RTCRtpEncodingParameters/scalabilityMode}} value
               represents an "S mode".
             </li>
           </ol>
         </p>
         <p>
           The [="L1T1"=] scalability mode enables SVC encoding to be turned off
           using {{RTCRtpSender/setParameters()}}. If [="L1T1"=] is set using
           {{RTCRtpSender/setParameters()}} then it will be returned in response
           to {{RTCRtpSender/getParameters()}}.
         </p>
      </section>
      <section id="getparameters">
       <h3>{{RTCRtpSender/getParameters()}}</h3>
         <p>
           Before the initial negotiation has completed,
           {{RTCRtpSender/getParameters()}} returns the
           {{RTCRtpEncodingParameters/scalabilityMode}} value for each
           encoding in <var>encodings</var>, as last set by
           {{RTCPeerConnection/addTransceiver()}} or
           {{RTCRtpSender/setParameters()}}. If no
           {{RTCRtpEncodingParameters/scalabilityMode}} value
           was provided for an encoding in <var>encodings</var>,
           or if a value was not successfully set, then
           {{RTCRtpSender/getParameters()}} will not return a
           {{RTCRtpEncodingParameters/scalabilityMode}} value
           for that encoding.
         </p>
         <p>
           After the initial negotiation has completed, {{RTCRtpSender/getParameters()}}
           returns the currently configured {{RTCRtpEncodingParameters/scalabilityMode}}
           value for each encoding in <var>encodings</var> which had a value before the
           initial negotiation. This MAY be different from the values requested in
           {{RTCPeerConnection/addTransceiver()}} or {{RTCRtpSender/setParameters()}}.
           For example, if the codecs selected during negotiation do not include an
           encoder supporting the desired {{RTCRtpEncodingParameters/scalabilityMode}}
           value, the user agent MAY select another value. If the configuration is not
           satisfactory, {{RTCRtpSender/setParameters()}} can be used to change it.
         </p>
         <p>
           If {{RTCPeerConnection/addTransceiver()}} or {{RTCRtpSender/setParameters()}}
           did not provide a {{RTCRtpEncodingParameters/scalabilityMode}} value for    
           an encoding in <var>encodings</var>, then after the initial negotiation
           has completed, {{RTCRtpSender/getParameters()}} will not return a
           {{RTCRtpEncodingParameters/scalabilityMode}} value and the encoder will use
           the default {{RTCRtpEncodingParameters/scalabilityMode}} of the most preferred
           codec for that encoding. The most preferred codec and the default
           {{RTCRtpEncodingParameters/scalabilityMode}} for each codec are both
           implementation dependent. The default
           {{RTCRtpEncodingParameters/scalabilityMode}} SHOULD be one of the
           temporal scalability modes (e.g. [="L1T1"=],[="L1T2"=],[="L1T3"=], etc.).
         </p>
      </section>
    </section>
  </section>
  <section id="discovery">
    <h2>Discovery</h2>
      <p>
        The [[?Media-Capabilities]] API provides information on encoder support
        for spatial scalability modes. {{VideoConfiguration//scalabilityMode}} is
        used to query whether an encoder has the ability to support this mode.
        The <a title="Selective Forwarding Middlebox">SFM</a>
        can provide information on the codecs and scalability modes it can
        decode by providing its receiver capabilities.
        After exchanging capabilities, the application can compute the
        intersection of codecs and {{RTCRtpEncodingParameters/scalabilityMode}}
        values supported by the browser's {{RTCRtpSender}} and the
        <a title="Selective Forwarding Middlebox">SFM</a>'s receiver. This
        can be used to determine the arguments passed to the browser's
        {{RTCPeerConnection/addTransceiver()}} and {{RTCRtpSender/setParameters()}}
        methods.
      </p>
      <p>
        The [[?Media-Capabilities]] API also provides information on decoder support
        for spatial scalablity modes. {{VideoConfiguration/spatialScalability}}
        indicates whether a decoder has the ability to support spatial prediction,
        which requires the ability to use frames of a resolution different than
        the current resolution as a dependency. If {{VideoConfiguration/spatialScalability}}
        is set to <code>true</code>, the decoder can decode any
        {{RTCRtpEncodingParameters/scalabilityMode}} value supported by the encoder.
        If {{VideoConfiguration/spatialScalability}} is set to <code>false</code>
        or is absent, the decoder cannot decode spatial scalability modes, but can
        can decode all other {{RTCRtpEncodingParameters/scalabilityMode}} values
        supported by the encoder.
      </p>
      <section id="sfmnegotiation">
        <h2>Negotiation</h2>
          <p>
            There are situations where an <a title="Selective Forwarding Middlebox">SFM</a>
            may only support reception of a subset of codecs and scalability modes.
            For example, an <a title="Selective Forwarding Middlebox">SFM</a> that parses
            codec payloads may only support the H.264/AVC codec without scalability and
            the VP8 codec with temporal scalability. On the other hand, the browser
            may be able to encode VP8 with temporal scalability, VP9 with temporal
            and spatial scalability and or H.264/AVC with temporal scalability.
            In such a situation, an application desiring to use SVC would only
            be able to encode VP8 with temporal scalability.
          </p>
          <p>
            Since sending simulcast encodings on a single stream is not negotiated within
            Offer/Answer, an application using SDP signaling needs to determine whether
            single stream simulcast transport is supported prior to the Offer/Answer negotiation.
            This can be handled by having the <a title="Selective Forwarding Middlebox">SFM</a>
            send it's receiver capabilities to the application prior to Offer/Answer.
            This allows the application to determine whether single stream simulcast is
            supported, and if so, what scalability modes the
            <a title="Selective Forwarding Middlebox">SFM</a> can handle. For example,
            an <a title="Selective Forwarding Middlebox">SFM</a> that can only support
            reception of a maximum of 2 simulcast encodings on a single SSRC with the
            AV1 codec would only indicate support for the [="S2T1"=] and [="S2T1h"=] scalability
            modes in its receiver capabilities.
          </p>
          <p>
           For an <a title="Selective Forwarding Middlebox">SFM</a> the supported
           {{RTCRtpEncodingParameters/scalabilityMode}} values may depend on the negotiated RTP
           header extensions.  For example, if the <a title="Selective Forwarding Middlebox">SFM</a>
           cannot parse codec payloads (either because it is not designed to do so, or
           because the payloads are encrypted), then negotiation of an RTP header extension
           (such as the AV1 Dependency Descriptor defined in Appendix A of [[AV1-RTP]])
           could be a prerequisite for the <a title="Selective Forwarding Middlebox">SFM</a>
           to forward a {{RTCRtpEncodingParameters/scalabilityMode}} value. As a result,
           the {{RTCRtpEncodingParameters/scalabilityMode}} values supported by an
           <a title="Selective Forwarding Middlebox">SFM</a> may not be determined until
           completion of the Offer/Answer negotiation.
          </p>
        </section>
  </section>
  <section id="scalabilitymodes*">
    <h3>Scalability modes</h3>
    <p>
      The {{RTCRtpEncodingParameters/scalabilityMode}} values supported in this specification,
      as well as their associated identifiers and characteristics, are provided in the table
      below. The names of the {{RTCRtpEncodingParameters/scalabilityMode}} values (which are
      case sensitive) are provided, along with the scalability mode identifiers assigned in
      [[?AV1]] Section 6.7.5, and links to dependency diagrams provided in Section 10.
    </p>
    <p>
      While the [[?AV1]] and VP9 [[?VP9]] specifications support all the
      {{RTCRtpEncodingParameters/scalabilityMode}} values defined in the table, other codec
      specifications do not. For example, VP8 [[?RFC6386]] only supports temporal scalability
      (e.g. [="L1T2"=], [="L1T3"=]); H.264/SVC [[?RFC6190]], which supports both temporal and
      spatial scalability, only permits transport of simulcast on distinct SSRCs, so that it
      does not support "S" modes, where multiple encodings are transported on a single RTP stream.
    </p>
    <table class=simple>
      <tbody>
        <tr>
          <th>Scalability Mode Identifier</th>
          <th>Spatial Layers</th>
          <th>Resolution Ratio</th>
          <th>Temporal Layers</th>
          <th>Inter-layer dependency</th>
          <th>AV1 scalability_mode_idc</th>
        </tr>
      </tbody>
      <tbody>
        <tr>
          <td><dfn data-export data-for="RTCRtpEncodingParameters/scalabilityMode"><a href="#L1T1*">"L1T1"</a></dfn></td>
          <td>1</td>
          <td></td>
          <td>1</td>
          <td></td>
          <td>N/A</td>
        </tr>
        <tr>
          <td><dfn data-export data-for="RTCRtpEncodingParameters/scalabilityMode"><a href="#L1T2*">"L1T2"</a></dfn></td>
          <td>1</td>
          <td></td>
          <td>2</td>
          <td></td>
          <td>SCALABILITY_L1T2</td>
        </tr>
        <tr>
          <td><dfn data-export data-for="RTCRtpEncodingParameters/scalabilityMode"><a href="#L1T3*">"L1T3"</a></dfn></td>
          <td>1</td>
          <td></td>
          <td>3</td>
          <td></td>
          <td>SCALABILITY_L1T3</td>
        </tr>
        <tr>
          <td><dfn data-export data-for="RTCRtpEncodingParameters/scalabilityMode"><a href="#L2T1*">"L2T1"</a></dfn></td>
          <td>2</td>
          <td>2:1</td>
          <td>1</td>
          <td>Yes</td>
          <td>SCALABILITY_L2T1</td>
        </tr>
        <tr>
          <td><dfn data-export data-for="RTCRtpEncodingParameters/scalabilityMode"><a href="#L2T2*">"L2T2"</a></dfn></td>
          <td>2</td>
          <td>2:1</td>
          <td>2</td>
          <td>Yes</td>
          <td>SCALABILITY_L2T2</td>
        </tr>
        <tr>
          <td><dfn data-export data-for="RTCRtpEncodingParameters/scalabilityMode"><a href="#L2T3*">"L2T3"</a></dfn></td>
          <td>2</td>
          <td>2:1</td>
          <td>3</td>
          <td>Yes</td>
          <td>SCALABILITY_L2T3</td>
        </tr>
        <tr>
          <td><dfn data-export data-for="RTCRtpEncodingParameters/scalabilityMode"><a href="#L3T1*">"L3T1"</a></dfn></td>
          <td>3</td>
          <td>2:1</td>
          <td>1</td>
          <td>Yes</td>
          <td>SCALABILITY_L3T1</td>
        </tr>
        <tr>
          <td><dfn data-export data-for="RTCRtpEncodingParameters/scalabilityMode"><a href="#L3T2*">"L3T2"</a></dfn></td>
          <td>3</td>
          <td>2:1</td>
          <td>2</td>
          <td>Yes</td>
          <td>SCALABILITY_L3T2</td>
        </tr>
        <tr>
          <td><dfn data-export data-for="RTCRtpEncodingParameters/scalabilityMode"><a href="#L3T3*">"L3T3"</a></dfn></td>
          <td>3</td>
          <td>2:1</td>
          <td>3</td>
          <td>Yes</td>
          <td>SCALABILITY_L3T3</td>
        </tr>
        <tr>
          <td><dfn data-export data-for="RTCRtpEncodingParameters/scalabilityMode"><a href="#L2T1*">"L2T1h"</a></dfn></td>
          <td>2</td>
          <td>1.5:1</td>
          <td>1</td>
          <td>Yes</td>
          <td>SCALABILITY_L2T1h</td>
        </tr>
        <tr>
          <td><dfn data-export data-for="RTCRtpEncodingParameters/scalabilityMode"><a href="#L2T2*">"L2T2h"</a></dfn></td>
          <td>2</td>
          <td>1.5:1</td>
          <td>2</td>
          <td>Yes</td>
          <td>SCALABILITY_L2T2h</td>
        </tr>
        <tr>
          <td><dfn data-export data-for="RTCRtpEncodingParameters/scalabilityMode"><a href="#L2T3*">"L2T3h"</a></dfn></td>
          <td>2</td>
          <td>1.5:1</td>
          <td>3</td>
          <td>Yes</td>
          <td>SCALABILITY_L2T3h</td>
        </tr>
        <tr>
          <td><dfn data-export data-for="RTCRtpEncodingParameters/scalabilityMode"><a href="#S2T1*">"S2T1"</a></dfn></td>
          <td>2</td>
          <td>2:1</td>
          <td>1</td>
          <td>No</td>
          <td>SCALABILITY_S2T1</td>
        </tr>
        <tr>
          <td><dfn data-export data-for="RTCRtpEncodingParameters/scalabilityMode"><a href="#S2T2*">"S2T2"</a></dfn></td>
          <td>2</td>
          <td>2:1</td>
          <td>2</td>
          <td>No</td>
          <td>SCALABILITY_S2T2</td>
        </tr>
        <tr>
          <td><dfn data-export data-for="RTCRtpEncodingParameters/scalabilityMode"><a href="#S2T3*">"S2T3"</a></dfn></td>
          <td>2</td>
          <td>2:1</td>
          <td>3</td>
          <td>No</td>
          <td>SCALABILITY_S2T3</td>
        </tr>
        <tr>
          <td><dfn data-export data-for="RTCRtpEncodingParameters/scalabilityMode"><a href="#S2T1*">"S2T1h"</a></dfn></td>
          <td>2</td>
          <td>1.5:1</td>
          <td>1</td>
          <td>No</td>
          <td>SCALABILITY_S2T1h</td>
        </tr>
        <tr>
          <td><dfn data-export data-for="RTCRtpEncodingParameters/scalabilityMode"><a href="#S2T2*">"S2T2h"</a></dfn></td>
          <td>2</td>
          <td>1.5:1</td>
          <td>2</td>
          <td>No</td>
          <td>SCALABILITY_S2T2h</td>
        </tr>
        <tr>
          <td><dfn data-export data-for="RTCRtpEncodingParameters/scalabilityMode"><a href="#S2T3*">"S2T3h"</a></dfn></td>
          <td>2</td>
          <td>1.5:1</td>
          <td>3</td>
          <td>No</td>
          <td>SCALABILITY_S2T3h</td>
        </tr>
        <tr>
          <td><dfn data-export data-for="RTCRtpEncodingParameters/scalabilityMode"><a href="#S3T1*">"S3T1"</a></dfn></td>
          <td>3</td>
          <td>2:1</td>
          <td>1</td>
          <td>No</td>
          <td>SCALABILITY_S3T1</td>
        </tr>
        <tr>
          <td><dfn data-export data-for="RTCRtpEncodingParameters/scalabilityMode"><a href="#S3T2*">"S3T2"</a></dfn></td>
          <td>3</td>
          <td>2:1</td>
          <td>2</td>
          <td>No</td>
          <td>SCALABILITY_S3T2</td>
        </tr>
        <tr>
          <td><dfn data-export data-for="RTCRtpEncodingParameters/scalabilityMode"><a href="#S3T3*">"S3T3"</a></dfn></td>
          <td>3</td>
          <td>2:1</td>
          <td>3</td>
          <td>No</td>
          <td>SCALABILITY_S3T3</td>
        </tr>
        <tr>
          <td><dfn data-export data-for="RTCRtpEncodingParameters/scalabilityMode"><a href="#S3T1*">"S3T1h"</a></dfn></td>
          <td>3</td>
          <td>1.5:1</td>
          <td>1</td>
          <td>No</td>
          <td>SCALABILITY_S3T1h</td>
        </tr>
        <tr>
          <td><dfn data-export data-for="RTCRtpEncodingParameters/scalabilityMode"><a href="#S3T2*">"S3T2h"</a></dfn></td>
          <td>3</td>
          <td>1.5:1</td>
          <td>2</td>
          <td>No</td>
          <td>SCALABILITY_S3T2h</td>
        </tr>
        <tr>
          <td><dfn data-export data-for="RTCRtpEncodingParameters/scalabilityMode"><a href="#S3T3*">"S3T3h"</a></dfn></td>
          <td>3</td>
          <td>1.5:1</td>
          <td>3</td>
          <td>No</td>
          <td>SCALABILITY_S3T3h</td>
        </tr>
        <tr>
          <td><dfn data-export data-for="RTCRtpEncodingParameters/scalabilityMode"><a href="#L2T2_KEY*">"L2T2_KEY"</a></dfn></td>
          <td>2</td>
          <td>2:1</td>
          <td>2</td>
          <td>Yes</td>
          <td>SCALABILITY_L3T2_KEY</td>
        </tr>
        <tr>
          <td><dfn data-export data-for="RTCRtpEncodingParameters/scalabilityMode"><a href="#L2T2_KEY_SHIFT*">"L2T2_KEY_SHIFT"</a></dfn></td>
          <td>2</td>
          <td>2:1</td>
          <td>2</td>
          <td>Yes</td>
          <td>SCALABILITY_L3T2_KEY_SHIFT</td>
        </tr>
        <tr>
          <td><dfn data-export data-for="RTCRtpEncodingParameters/scalabilityMode"><a href="#L2T3_KEY*">"L2T3_KEY"</a></dfn></td>
          <td>2</td>
          <td>2:1</td>
          <td>3</td>
          <td>Yes</td>
          <td>SCALABILITY_L3T3_KEY</td>
        </tr>
        <tr>
          <td><dfn data-export data-for="RTCRtpEncodingParameters/scalabilityMode"><a href="#L2T3_KEY_SHIFT*">"L2T3_KEY_SHIFT"</a></dfn></td>
          <td>2</td>
          <td>2:1</td>
          <td>3</td>
          <td>Yes</td>
          <td>SCALABILITY_L3T3_KEY_SHIFT</td>
        </tr>
        <tr>
          <td><dfn data-export data-for="RTCRtpEncodingParameters/scalabilityMode"><a href="#L3T2_KEY*">"L3T2_KEY"</a></dfn></td>
          <td>3</td>
          <td>2:1</td>
          <td>2</td>
          <td>Yes</td>
          <td>SCALABILITY_L4T5_KEY</td>
        </tr>
        <tr>
          <td><dfn data-export data-for="RTCRtpEncodingParameters/scalabilityMode"><a href="#L3T2_KEY_SHIFT*">"L3T2_KEY_SHIFT"</a></dfn></td>
          <td>3</td>
          <td>2:1</td>
          <td>2</td>
          <td>Yes</td>
          <td>SCALABILITY_L4T5_KEY_SHIFT</td>
        </tr>
        <tr>
          <td><dfn data-export data-for="RTCRtpEncodingParameters/scalabilityMode"><a href="#L3T3_KEY*">"L3T3_KEY"</a></dfn></td>
          <td>3</td>
          <td>2:1</td>
          <td>3</td>
          <td>Yes</td>
          <td>SCALABILITY_L4T7_KEY</td>
        </tr>
        <tr>
          <td><dfn data-export data-for="RTCRtpEncodingParameters/scalabilityMode"><a href="#L3T3_KEY_SHIFT*">"L3T3_KEY_SHIFT"</a></dfn></td>
          <td>3</td>
          <td>2:1</td>
          <td>3</td>
          <td>Yes</td>
          <td>SCALABILITY_L4T7_KEY_SHIFT</td>
        </tr>
      </tbody>
    </table>
    <section id="addingmodes*">
      <h3>Guidelines for addition of {{RTCRtpEncodingParameters/scalabilityMode}} values</h3>
      <p>When proposing a {{RTCRtpEncodingParameters/scalabilityMode}} value, the following principles should be followed:</p>
        <ol>
          <li>
            The proposed {{RTCRtpEncodingParameters/scalabilityMode}} MUST define entries to the table in
            Section 6, including values for the Scalabilty Mode Identifier, spatial and
            temporal layers, Resolution Ratio, Inter-layer dependency and the corresponding
            AV1 scalability_mode_idc value (if assigned).
          </li>
          <li>
            The Scalability Mode Identifier SHOULD be consistent with the existing naming scheme, which
            utilizes <code>L<var>x</var>T<var>y</var></code> to denote a {{RTCRtpEncodingParameters/scalabilityMode}} with <var>x</var>
            spatial layers using a 2:1 resolution ratio and <var>y</var> temporal layers.
            <code>L<var>x</var>T<var>y</var>h</code> denotes <var>x</var> spatial layers with a 1.5:1 resolution ratio and
            <var>y</var> temporal layers. <code>S<var>x</var>T<var>y</var></code> denotes a {{RTCRtpEncodingParameters/scalabilityMode}}
            with <var>x</var> simulcast encodings with a 2:1 resolution ratio, with each
            simulcast encoding containing <var>y</var> temporal layers. <code>S<var>x</var>T<var>y</var>h</code> denotes
            a 1.5:1 resolution ratio. <code>L<var>x</var>T<var>y</var>_KEY</code> denotes a {{RTCRtpEncodingParameters/scalabilityMode}}
            with <var>x</var> spatial layers using a 2:1 resolution ratio and <var>y</var> temporal layers in which spatial layers only
            depend on lower spatial layers at a key frame. <code>L<var>x</var>T<var>y</var>_KEY_SHIFT</code> modes denotes a
            {{RTCRtpEncodingParameters/scalabilityMode}} with <var>x</var> spatial layers using a 2:1 resolution ratio and
            <var>y</var> temporal layers in which spatial layers only depend on lower spatial layers at a key frame and subsequent
            frames have their temporal identifier shifted upward.
          </li>
          <li>
            A dependency diagram MUST be supplied, in the format provided in Section 10.
          </li>         
        </ol>
    </section>
  </section>
  <section id="rtcrtpencodingparameters-example*">
      <h3>Examples</h3>
        <section id="simulcasttemporal-example*" class="informative">
          <h4>Spatial Simulcast and Temporal Scalability</h4>
          <p>
            This example extends [[WEBRTC]] Section 7.1 (Example 1) to demonstrate sending three spatial
            simulcast layers each with three temporal layers, using an SSRC and RID for each simulcast
            layer. Only the "sendEncodings" attribute is changed from the original example.
          </p>
          <pre class="example highlight">
const signaling = new SignalingChannel(); // handles JSON.stringify/parse
const constraints = {audio: true, video: true};
const configuration = {'iceServers': [{'urls': 'stun:stun.example.org'}]};
let pc;

// call start() to initiate
async function start() {
  pc = new RTCPeerConnection(configuration);

  // let the "negotiationneeded" event trigger offer generation
  pc.onnegotiationneeded = async () => {
    try {
      await pc.setLocalDescription();
      // send the offer to the other peer
      signaling.send({description: pc.localDescription});
    } catch (err) {
      console.error(err);
    }
  };

  try {
    // get a local stream, show it in a self-view and add it to be sent
    const stream = await navigator.mediaDevices.getUserMedia(constraints);
    selfView.srcObject = stream;
    pc.addTransceiver(stream.getAudioTracks()[0], {direction: 'sendonly'});
    pc.addTransceiver(stream.getVideoTracks()[0], {
      direction: 'sendonly',
      sendEncodings: [
        {rid: 'q', scaleResolutionDownBy: 4.0, scalabilityMode: 'L1T3'}
        {rid: 'h', scaleResolutionDownBy: 2.0, scalabilityMode: 'L1T3'},
        {rid: 'f', scalabilityMode: 'L1T3'},
      ]    
    });
  } catch (err) {
    console.error(err);
  }
}

signaling.onmessage = async ({data: {description, candidate}}) => {
  try {
    if (description) {
      await pc.setRemoteDescription(description);
      // if we got an offer, we need to reply with an answer
      if (description.type == 'offer') {
        await pc.setLocalDescription();
        signaling.send({description: pc.localDescription});
      }
    } else if (candidate) {
      await pc.addIceCandidate(candidate);
    }
  } catch (err) {
    console.error(err);
  }
};
</pre>
           <p> This is an example with two spatial layers (with a 2:1 ratio) and three temporal layers.</p> 
          <pre class="example highlight">
let sendEncodings = [
  {scalabilityMode: 'L2T3'}
];
</pre>
           <p> This is an example with three spatial simulcast layers each with three temporal layers on a single SSRC.</p> 
          <pre class="example highlight">
let sendEncodings = [
  {scalabilityMode: 'S3T3'}
]    
</pre>
    </section>
    <section id="media-capabilities-example*" class="informative">
       <h4>SVC Encoder Capabilities</h4>
      <p>
        This is an example of {{MediaCapabilities/encodingInfo(configuration)}}
        returned by a browser implementing [[WEBRTC]] and [[Media-Capabilities]].
      </p>
       <pre class="example highlight">
const contentType = 'video/VP9';

const configuration = {
  type: 'webrtc',
  video: {
    contentType,
    width: 640,
    height: 480,
    bitrate: 10000,
    framerate: 29.97,
    scalabilityMode: "L3T3_KEY"
  }
};

try {
  const info = await navigator.mediaCapabilities.encodingInfo(configuration);

  if (!info.supported) {
    console.log(`${contentType} is unsupported.`);
    return;
  }
  console.log(`${contentType} is ${info.smooth || 'NOT '}smooth, and ` +
              `${info.powerEfficient || 'NOT '}power efficient`);
} catch (err) {
  console.error(err, ' caused encodingInfo to fail');
}
       </pre>
    </section>
        <section id="sfm-getcapabilities-example*" class="informative" >
       <h4><a title="Selective Forwarding Middlebox">SFM</a> Capabilities</h4>
       <p>
         This is an example of receiver capabilities returned by an
         <a title="Selective Forwarding Middlebox">SFM</a> that only
         supports forwarding of VP8, VP9 and AV1 temporal scalability modes.
       </p>
       <pre class="example highlight">
 "codecs": [
    {
      "clockRate": 90000,
      "mimeType": "video/VP8",
      "scalabilityModes": [
        "L1T1",
        "L1T2",
        "L1T3"
      ]
    },
    {
      "clockRate": 90000,
      "mimeType": "video/VP9",
      "scalabilityModes": [
        "L1T1",
        "L1T2",
        "L1T3",
        "L2T2h",
        "L2T3h"
      ]
    },
    {
      "clockRate": 90000,
      "mimeType": "video/AV1",
      "scalabilityModes": [
        "L1T1",
        "L1T2",
        "L1T3",
        "L2T2h",
        "L2T3h"
      ]
    }
]
</pre>
    </section>
    </section>
  <section class="informative"  id="privacy">
        <h2>Privacy Considerations</h2>
     <p>
       This section is non-normative; it specifies no new behaviour, but
       instead summarizes information already present in other parts of the
       specification. The privacy considerations
       for the WebRTC APIs are described in [[WEBRTC]] Section 13.
    </p>
    <section>
      <h2>Persistent information</h2>
      <p>
        Since for SVC codecs implemented in WebRTC the use of scalable coding tools
        is not negotiated and is independent of the supported profiles, and since SVC
        is rarely supported in hardware encoders, knowledge of the
        {{RTCRtpEncodingParameters/scalabilityMode}} supported by the {{RTCRtpSender}}
        does not provide additional information on the underlying hardware.
        However, since browsers may differ in their support for SVC modes, the supported
        {{RTCRtpEncodingParameters/scalabilityMode}} may permit differentiation
        between browsers. This additional fingerprint surface is expected to decrease
        over time as this specification is more widely implemented.
      </p>
    </section>
  </section>
  <section class="informative"  id="security">
    <h2>Security Considerations</h2>
    <p>
      This section is non-normative; it specifies no new behaviour, but
      instead summarizes information already present in other parts of the
      specification. WebRTC protocol security considerations are described
      in [[RTCWEB-SECURITY-ARCH]] and the security and privacy considerations
      for the WebRTC APIs are described in [[WEBRTC]] Section 13.
    </p>
  </section>
  <section id="dependencydiagrams*">
   <h2>Scalability Mode Dependency Diagrams</h2>
   <p>
     Dependency diagrams for the scability modes defined in this specification
     are provided below.
    </p>
   <section id="L1T1*">
   <h3>L1T1</h3>
          <figure>
            <img alt="L1T1: a single layer" src=
            "images/L1T1.svg" style="width:75%">
            <figcaption>
              L1T1: 1-layer encoding
            </figcaption>
          </figure>
   </section>
   <section id="L1T2*">
   <h3>L1T2</h3>
          <figure>
            <img alt="L1T2: 2-layer temporal scalability encoding" src=
            "images/L1T2.svg" style="width:75%">
            <figcaption>
              L1T2: 1-layer spatial and 2-layer temporal scalability encoding
            </figcaption>
          </figure>
   </section>
   <section id="L1T3*">
   <h3>L1T3</h3>
          <figure>
            <img alt="L1T3: 3-layer temporal scalability encoding" src=
            "images/L1T3.svg" style="width:75%">
            <figcaption>
              L1T3: 1-layer spatial and 3-layer temporal scalability encoding
            </figcaption>
          </figure>
   </section>
   <section id="L2T1*">
   <h3>L2T1 and L2T1h</h3>
          <figure>
            <img alt="L2T1 and L2T1h: 2-layer spatial and 1-layer temporal scalability encoding" src=
            "images/L2T1.svg" style="width:75%">
            <figcaption>
              L2T1 and L2T1h: 2-layer spatial and 1-layer temporal scalability encoding
            </figcaption>
          </figure>
   </section>
   <section id="L2T1_KEY*">
   <h3>L2T1_KEY</h3>
          <figure>
            <img alt="L2T1_KEY: 2-layer spatial and 1-layer temporal scalability K-SVC encoding" src=
            "images/L2T1_KEY.svg" style="width:75%">
            <figcaption>
              L2T1_KEY: 2-layer spatial and 1-layer temporal scalability K-SVC encoding
            </figcaption>
          </figure>
   </section>
   <section id="L2T2*">
   <h3>L2T2 and L2T2h</h3>
          <figure>
            <img alt="L2T2 and L2T2h: 2-layer spatial and 2-layer temporal scalability encoding" src=
            "images/L2T2.svg" style="width:75%">
            <figcaption>
              L2T2 and L2T2h: 2-layer spatial and 2-layer temporal scalability encoding
            </figcaption>
          </figure>
   </section>
   <section id="L2T2_KEY*">
   <h3>L2T2_KEY</h3>
          <figure>
            <img alt="L2T2_KEY: 2-layer spatial and 2-layer temporal scalability K-SVC encoding" src=
            "images/L2T2_KEY.svg" style="width:75%">
            <figcaption>
              L2T2_KEY: 2-layer spatial and 2-layer temporal scalability K-SVC encoding
            </figcaption>
          </figure>
   </section>
   <section id="L2T2_KEY_SHIFT*">
   <h3>L2T2_KEY_SHIFT</h3>
          <figure>
            <img alt="L2T2_KEY_SHIFT: 2-layer spatial and 2-layer temporal scalability K-SVC shifted encoding with temporal shift" src=
            "images/L2T2_KEY_SHIFT.svg" style="width:75%">
            <figcaption>
              L2T2_KEY_SHIFT: 2-layer spatial and 2-layer temporal scalability K-SVC encoding with temporal shift
            </figcaption>
          </figure>
   </section>
   <section id="L2T3*">
   <h3>L2T3 and L2T3h</h3>
          <figure>
            <img alt="L2T3 and L2T3h: 2-layer spatial and 3-layer temporal scalability encoding" src=
            "images/L2T3.svg" style="width:75%">
            <figcaption>
              L2T3 and L2T3h: 2-layer spatial and 3-layer temporal scalability encoding
            </figcaption>
          </figure>
   </section>
   <section id="L2T3_KEY*">
   <h3>L2T3_KEY</h3>
          <figure>
            <img alt="L2T3_KEY: 2-layer spatial and 3-layer temporal scalability K-SVC encoding" src=
            "images/L2T3_KEY.svg" style="width:75%">
            <figcaption>
              L2T3_KEY: 2-layer spatial and 3-layer temporal scalability K-SVC encoding
            </figcaption>
          </figure>
   </section>
   <section id="L2T3_KEY_SHIFT*">
   <h3>L2T3_KEY_SHIFT</h3>
          <figure>
            <img alt="L2T3_KEY_SHIFT: 2-layer spatial and 3-layer temporal scalability K-SVC shifted encoding with temporal shift" src=
            "images/L2T3_KEY_SHIFT.svg" style="width:75%">
            <figcaption>
              L2T3_KEY_SHIFT: 2-layer spatial and 3-layer temporal scalability K-SVC encoding with temporal shift
            </figcaption>
          </figure>
   </section>
   <section id="L3T1*">
   <h3>L3T1 and L3T1h</h3>
          <figure>
            <img alt="L3T1 and L3T1h: 3-layer spatial and 1-layer temporal scalability encoding" src=
            "images/L3T1.svg" style="width:75%">
            <figcaption>
              L3T1 and L3T1h: 3-layer spatial and 1-layer temporal scalability encoding
            </figcaption>
          </figure>
   </section>
   <section id="L3T1_KEY*">
   <h3>L3T1_KEY</h3>
          <figure>
            <img alt="L3T1_KEY: 3-layer spatial and 1-layer temporal scalability K-SVC encoding" src=
            "images/L3T1_KEY.svg" style="width:75%">
            <figcaption>
              L3T1_KEY: 3-layer spatial and 1-layer temporal scalability K-SVC encoding
            </figcaption>
          </figure>
   </section>
   <section id="L3T2*">
   <h3>L3T2 and L3T2h</h3>
          <figure>
            <img alt="L3T2 and L3T2h: 3-layer spatial and 2-layer temporal scalability encoding" src=
            "images/L3T2.svg" style="width:75%">
            <figcaption>
              L3T2 and L3T2h: 3-layer spatial and 2-layer temporal scalability encoding
            </figcaption>
          </figure>
   </section>
   <section id="L3T2_KEY*">
   <h3>L3T2_KEY</h3>
          <figure>
            <img alt="L3T2_KEY: 3-layer spatial and 2-layer temporal scalability K-SVC encoding" src=
            "images/L3T2_KEY.svg" style="width:75%">
            <figcaption>
              L3T2_KEY: 3-layer spatial and 2-layer temporal scalability K-SVC encoding
            </figcaption>
          </figure>
   </section>
   <section id="L3T2_KEY_SHIFT*">
   <h3>L3T2_KEY_SHIFT</h3>
          <figure>
            <img alt="L3T2_KEY_SHIFT: 3-layer spatial and 2-layer temporal scalability K-SVC with temporal shift" src=
            "images/L3T2_KEY_SHIFT.svg" style="width:75%">
            <figcaption>
              L3T2_KEY_SHIFT: 3-layer spatial and 2-layer temporal scalability K-SVC with temporal shift
            </figcaption>
          </figure>
   </section>
   <section id="L3T3*">
   <h3>L3T3 and L3T3h</h3>
          <figure>
            <img alt="L3T3 and L3T3h: 3-layer spatial and 3-layer temporal scalability encoding" src=
            "images/L3T3.svg" style="width:75%">
            <figcaption>
              L3T3 and L3T3h: 3-layer spatial and 3-layer temporal scalability encoding
            </figcaption>
          </figure>
   </section>
   <section id="L3T3_KEY*">
   <h3>L3T3_KEY</h3>
          <figure>
            <img alt="L3T3_KEY: 3-layer spatial and 3-layer temporal scalability K-SVC encoding" src=
            "images/L3T3_KEY.svg" style="width:75%">
            <figcaption>
              L3T3_KEY: 3-layer spatial and 3-layer temporal scalability K-SVC encoding
            </figcaption>
          </figure>
   </section>
   <section id="L3T3_KEY_SHIFT*">
   <h3>L3T3_KEY_SHIFT</h3>
          <figure>
            <img alt="L3T3_KEY_SHIFT: 3-layer spatial and 3-layer temporal scalability K-SVC with temporal shift" src=
            "images/L3T3_KEY_SHIFT.svg" style="width:75%">
            <figcaption>
              L3T3_KEY_SHIFT: 3-layer spatial and 3-layer temporal scalability K-SVC with temporal shift
            </figcaption>
          </figure>
   </section>
   <section id="S2T1*">
   <h3>S2T1 and S2T1h</h3>
          <figure>
            <img alt="S2T1 and S2T1h: 2-layer spatial simulcast encoding" src=
            "images/S2T1.svg" style="width:75%">
            <figcaption>
              S2T1 and S2T1h: 2-layer spatial simulcast encoding
            </figcaption>
          </figure>
   </section>
   <section id="S2T2*">
   <h3>S2T2 and S2T2h</h3>
          <figure>
            <img alt="S2T2 and S2T2h: 2-layer spatial simulcast and 2-layer temporal scalability encoding" src=
            "images/S2T2.svg" style="width:75%">
            <figcaption>
              S2T2 and S2T2h: 2-layer spatial simulcast and 2-layer temporal scalability encoding
            </figcaption>
          </figure>
   </section>
   <section id="S2T3*">
   <h3>S2T3 and S2T3h</h3>
          <figure>
            <img alt="S2T3 and S2T3h: 2-layer spatial simulcast and 3-layer temporal scalability encoding" src=
            "images/S2T3.svg" style="width:75%">
            <figcaption>
              S2T3 and S2T3h: 2-layer spatial simulcast and 3-layer temporal scalability encoding
            </figcaption>
          </figure>
   </section>
   <section id="S3T1*">
   <h3>S3T1 and S3T1h</h3>
          <figure>
            <img alt="S3T1 and S3T1h: 3-layer spatial simulcast encoding" src=
            "images/S3T1.svg" style="width:75%">
            <figcaption>
              S3T1 and S3T1h: 3-layer spatial simulcast encoding
            </figcaption>
          </figure>
   </section>
   <section id="S3T2*">
   <h3>S3T2 and S3T2h</h3>
          <figure>
            <img alt="S3T2 and S3T2h: 3-layer spatial simulcast and 2-layer temporal scalability encoding" src=
            "images/S3T2.svg" style="width:75%">
            <figcaption>
              S3T2 and S3T2h: 3-layer spatial simulcast and 2-layer temporal scalability encoding
            </figcaption>
          </figure>
   </section>
   <section id="S3T3*">
   <h3>S3T3 and S3T3h</h3>
          <figure>
            <img alt="S3T3 and S3T3h: 3-layer spatial simulcast and 3-layer temporal scalability encoding" src=
            "images/S3T3.svg" style="width:75%">
            <figcaption>
              S3T3 and S3T3h: 3-layer spatial simulcast and 3-layer temporal scalability encoding
            </figcaption>
          </figure>
   </section>
 </section>
 <section class="appendix">
   <h2>Acknowledgements</h2>
      <p>
        The editors wish to thank Robin Raymond, Michael Horowitz, Harald Alvestrand,
        Chris Cunningham, Danil Chapovalov and Florent Castelli for their contributions
        to this specification, which evolved from the ORTC API developed in the
        <a href="https://www.w3.org/community/ortc/">W3C ORTC CG</a>.
      </p>
  </section>
</body>
</html>
