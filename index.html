<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8">
  <link href="webrtc.css" rel="stylesheet">
  <title>Scalable Video Coding (SVC) Extension for WebRTC</title>
  <script class="remove" src="https://www.w3.org/Tools/respec/respec-w3c"></script>
  <script class="remove" src="svc-respec-config.js" ></script>
</head>
<body>
  <section id="abstract">
    <p>This document defines a set of ECMAScript APIs in WebIDL to extend the WebRTC 1.0 API
    to enable user agents to support scalable video coding (SVC).</p>
  </section>
  <section id="sotd">
    <p>The API is based on preliminary work done in the W3C ORTC Community Group.</p>
  </section>
  <section class="informative" id="intro">
    <h2>Introduction</h2>
    <p>This specification extends the WebRTC specification [[WEBRTC]] to
    enable configuration of encoding parameters for Scalable Video Coding (SVC).
    While this specification does not support decoder configuration, it does enable
    decoders to indicate supported scalability modes.</p>
  </section>
  <section id="conformance">
    <p>This specification defines conformance criteria that apply to a single
    product: the <dfn>user agent</dfn> that implements the interfaces that it
    contains.</p>
    <p>Conformance requirements phrased as algorithms or specific steps may be
    implemented in any manner, so long as the end result is equivalent. (In
    particular, the algorithms defined in this specification are intended to be
    easy to follow, and not intended to be performant.)</p>
    <p>Implementations that use ECMAScript to implement the APIs defined in
    this specification MUST implement them in a manner consistent with the
    ECMAScript Bindings defined in the Web IDL specification [[WEBIDL]], as
    this specification uses that specification and terminology.</p>
  </section>
  <section>
    <h2>Terminology</h2>
      <p>The term <dfn>simulcast envelope</dfn> refers to the maximum number of
      simulcast streams and the order of the encoding parameters.</p>
    <p>This specification references objects, methods, internal slots and dictionaries defined in
    [[!WEBRTC]]</p>
       <p>For Scalable Video Coding (<dfn>SVC</dfn>), the terms single-session transmission
      (<dfn>SST</dfn>) and multi-session transmission (<dfn>MST</dfn>) are
      defined in [[?RFC6190]]. This specification only supports <a>SST</a> but
      not <a>MST</a>.</p>
      <p>The term Single Real-time Transport Protocol stream
      Single Transport (<dfn>SRST</dfn>), defined in [[RFC7656]] Section 3.7,
      refers to SVC implementations that transmit all layers within a
      single transport, using a single Real-time Transport Protocol (RTP) stream and synchronization source
      (SSRC). The term Multiple RTP stream Single Transport (<dfn>MRST</dfn>),
      also defined in [[RFC7656]] Section 3.7, refers to implementations that
      transmit all layers within a single transport, using multiple RTP streams
      with a distinct SSRC for each layer.  This specification only supports
      <a>SRST</a>, not <a>MRST</a>. Codecs with RTP payload
      specifications supporting <a>SRST</a> include VP8
      [[?RFC7741]], VP9 [[?VP9-PAYLOAD]], AV1 [[?AV1-RTP]] and H.264/SVC
      [[?RFC6190]].</p>
      <p>The term "S mode" refers to a scalability mode in which multiple
      encodings are sent on the same SSRC. This includes the "S2T1", "S2T1h",
      "S2T2", "S2T2h", "S2T3", "S2T3h", "S3T1", "S3T1h", "S3T2", "S3T2h",
      "S3T3" and "S3T3h" {{RTCRtpEncodingParameters/scalabilityMode}} values.</p>
      <p>The term "Selective Forwarding Middlebox (SFM)" is defined in Section 3.7 of [[RFC7667]].<p>
  </section>
  <section id="operational-model">
    <h2>Operational model</h2>
    <p>This specification extends [[!WEBRTC]] to enable configuration of encoding
    parameters for SVC, as well as discovery of the SVC capabilities of both an
    encoder and decoder, by extending the {{RTCRtpEncodingParameters}}
    and {{RTCRtpCodecCapability}} dictionaries.</p>
    <p>Since this specification does not change the behavior of WebRTC
    objects and methods, restrictions relating to Offer/Answer negotiation and
    encoding parameters remain, as described in [[!WEBRTC]] Section 5.2: 
    "{{RTCRtpSender/setParameters()}} does not cause SDP renegotiation and can
    only be used to change what the media stack is sending or receiving within the
    envelope negotiated by Offer/Answer."</p>
    <p>The configuration of SVC-capable codecs implemented in browsers fits within this
    restriction. Codecs such as VP8 [[?RFC6386]], VP9 [[?VP9]] and AV1 [[?AV1]] mandate support
    for scalable video coding tools. Therefore these codecs do not negotiate SVC support
    within Offer/Answer, enabling encoding parameters to be used for SVC configuration.</p>
    <section id="error-handling">
      <h2>Error handling</h2>
      <p>
        [[!WEBRTC]] Section 5.2 describes error handling in
        {{RTCRtpSender/setParameters()}}, including use of {{RTCError}}
        to indicate a {{RTCErrorDetailType/"hardware-encoder-error"}}
        due to an unsupported encoding parameter, as well as
        {{OperationError}} for other errors. Implementations of this
        specification utilize {{RTCError}} and {{OperationError}}
        in the prescribed manner when an invalid
        {{RTCRtpEncodingParameters/scalabilityMode}} value is provided to 
        {{RTCRtpSender/setParameters()}} or {{RTCPeerConnection/addTransceiver()}}.
      </p>
      <p>
        When the {{RTCPeerConnection/addTransceiver()}} and
        {{RTCRtpTransceiver/setCodecPreferences()}} methods are called
        prior to conclusion of the Offer/Answer negotiation, the negotiated
        codec and its capabilities may not be known. In this situation the
        {{RTCRtpEncodingParameters/scalabilityMode}} values configured
        in {{RTCRtpTransceiverInit/sendEncodings}} may not be supported
        by the eventually negotiated codec. However, an error will result only
        if the requested {{RTCRtpEncodingParameters/scalabilityMode}} value is
        invalid for any supported codec. To determine whether the requested
        {{RTCRtpEncodingParameters/scalabilityMode}} values have been applied,
        an application can call the {{RTCRtpSender.getParameters()}} method
        after negotiation has completed and the sending codec has been determined.
        If the configuration is not satisfactory, the
        {{RTCRtpSender/setParameters()}} method can be used to change it.
      </p>
      <p>
        Note that where SVC support is negotiated in SDP Offer/Answer,
        {{RTCRtpSender/setParameters()}} can only change
        {{RTCRtpEncodingParameters/scalabilityMode}} values within the envelope
        negotiated by Offer/Answer, resulting in an error if the requested
        {{RTCRtpEncodingParameters/scalabilityMode}} value is outside this envelope.
        When {{RTCRtpTransceiverInit/sendEncodings}} is used to
        request the sending of multiple simulcast streams using
        {{RTCPeerConnection/addTransceiver()}}, it is not possible to
        configure the sending of "S" scalability modes. The browser
        may only be configured to send simulcast encodings with
        multiple SSRCs and RIDs, or alternatively, to send all
        simulcast encodings on a single RTP stream. Attempting to
        simultaneously utilize both simulcast transport
        techniques MUST return {{OperationError}} in
        {{RTCRtpSender/setParameters()}} or
        {{RTCPeerConnection/addTransceiver()}}.
      </p>
    </section>
    <section id="negotiation">
      <h2>Negotiation</h2>
      <p>
        So as to ensure that the desired {{RTCRtpEncodingParameters/scalabilityMode}}
        values can be applied, {{RTCRtpTransceiver/setCodecPreferences()}} can be
        used to limit the negotiated codecs to those supporting the desired configuration.
        For example, if temporal scalability is desired along with spatial simulcast,
        when {{RTCPeerConnection/addTransceiver()}} is called,
        {{RTCRtpTransceiverInit/sendEncodings}} can be configured to send multiple
        simulcast streams with different resolutions, with each stream
        utilizing temporal scalability. If only the VP8, VP9 and AV1 codec implementations
        support temporal scalability, {{RTCRtpTransceiver/setCodecPreferences()}}
        can be used to remove the H.264/AVC codec from the Offer, guaranteeing that
        a codec supporting temporal scalability is negotiated.
      </p>
      <p>
        There are situations where a peer may only support reception of a subset
        of codecs and scalability modes. For example, an SFM that parses codec
        payloads may only support the H.264/AVC codec without scalability and
        the H.264/SVC codec with temporal scalability. However, a browser that
        can decode VP8 or VP9 may not support H.264/SVC or AV1.
        In these situations, the {{RTCRtpReceiver}}'s <code>getCapabilities</code>
        method can be used to determine the scalability modes supported by the
        {{RTCRtpReceiver}}, and the {{RTCRtpSender}}'s <code>getCapabilities</code>
        method can be used to determine the scalability modes supported by the
        {{RTCRtpSender}}. After exchanging capabilities, the application can compute
        which codecs and {{RTCRtpEncodingParameters/scalabilityMode}} values are
        supported by both the browser and SFM. The intersection of codecs and
        scalability modes supported by the browser's {{RTCRtpSender}} and the SFM's
        receiver can then be used to determine the arguments passed to the browser's
        {{RTCPeerConnection/addTransceiver()}} and {{RTCRtpSender/setParameters()}} methods.
      </p>
      <p>
        Since sending simulcast encodings on a single stream is not negotiated within
        Offer/Answer, an application using SDP signaling needs to determine whether
        single stream simulcast transport is supported prior to the Offer/Answer negotiation.
        This can be handled by having the SFM send it's receiver capabilities to the
        application prior to Offer/Answer. This allows the application to determine
        whether single stream simulcast is supported, and if so, what scalability
        modes the SFM can handle. For example, an SFM that can only support reception
        of a maximum of 2 simulcast encodings on a single SSRC with the AV1 codec would
        only indicate support for the "S2T1" and "S2T1h" scalability modes in its
        receiver capabilities.
      </p>
    </section>
  </section>
  <section id="rtpdictionaries">
    <h2>Dictionary extensions</h2>
    <section id="rtcrtpencodingparameters">
      <h3>RTCRtpEncodingParameters Dictionary Extensions</h3>
      <div>
        <pre class="idl">partial dictionary RTCRtpEncodingParameters {
             DOMString scalabilityMode;
};</pre>
        <section>
          <h2>Dictionary {{RTCRtpEncodingParameters}} Members</h2>
          <dl data-link-for="RTCRtpEncodingParameters" data-dfn-for=
          "RTCRtpEncodingParameters" class="dictionary-members">
            <dt><dfn data-idl>scalabilityMode</dfn> of type {{DOMString}}</dt>
            <dd>
              <p>A case-sensitive identifier of the scalability mode to be used for this stream.
              The {{RTCRtpEncodingParameters/scalabilityMode}} selected MUST be one of the scalability modes
              supported for the codec, as indicated in {{RTCRtpCodecCapability}}.
              Scalability modes are defined in Section 6.</p>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <section id="rtcrtpcodeccapability*">
      <h3>{{RTCRtpCodecCapability}} Dictionary Extensions</h3>
      <div>
        <pre class="idl">partial dictionary RTCRtpCodecCapability {
             sequence&lt;DOMString&gt; scalabilityModes;
};</pre>
        <section>
          <h2>Dictionary {{RTCRtpCodecCapability}} Members</h2>
          <dl data-link-for="RTCRtpCodecCapability" data-dfn-for=
          "RTCRtpCodecCapability" class="dictionary-members">
            <dt><dfn data-idl>scalabilityModes</dfn> of type <code>sequence&lt;{{DOMString}}&gt;</code></dt>
            <dd>
              <p>A sequence of the scalability modes (defined in Section 6) supported by the encoder
              implementation.</p>
              <p>In response to a call to {{RTCRtpSender}}<code>.getCapabilities(<var>kind</var>)</code>,
              conformant implementations of this specification MUST return a sequence of
              scalability modes supported by each codec of that <var>kind</var>. If a codec does not support
              encoding of scalability modes other than "L1T1", then the {{scalabilityModes}} member
              is not provided. The "L1T1" scalability mode enables SVC encoding to be turned off using
              {{RTCRtpSender/setParameters()}}, so that it MUST be included within the sequence of
              scalability modes returned by {{RTCRtpSender}}<code>.getCapabilities()</code> in order
              for it to be considered valid within {{RTCRtpSender/setParameters()}}. If "L1T1" is set
              using {{RTCRtpSender/setParameters()}} then it will be returned in response to
              {{RTCRtpSender/getParameters()}}.</p>
              <p>In response to a call to {{RTCRtpReceiver}}<code>.getCapabilities(<var>kind</var>)</code>,
              decoders that do not support decoding of scalability modes or that can
              decode any scalability mode omit the {{scalabilityModes}} member. However, decoders that only support
              decoding of a subset of scalability modes MUST return a sequence of the scalability
              modes supported by that codec.</p>
              <p class="note">
                  The {{scalabilityModes}} sequence represents the scalability modes supported
                  by a peer. For an SFM the supported {{scalabilityModes}} may depend on the
                  negotiated RTP header extensions. For example, if the SFM cannot parse codec
                  payloads (either because it is not designed to do so, or because the payloads
                  are encrypted), then negotiation of an RTP header extension (such as the
                  AV1 Dependency Descriptor defined in Appendix A of [[AV1-RTP]]) could be
                  a prerequisite for the SFM to forward {{scalabilityModes}}. As a result, the
                  {{scalabilityModes}} supported by an SFM may not be determined until
                  completion of the Offer/Answer negotiation.
              </p>
            </dd>
          </dl>
        </section>
      </div>
    </section>
  </section>
  <section id="scalabilitymodes*">
     <h3>Scalability modes</h3>
     <p>The scalability modes supported in this specification, as well as their associated
     identifiers and characteristics, are provided in the table below. The names of the
     scability modes (which are case sensitive) are provided, along with the scalability
     mode identifiers assigned in [[?AV1]] Section 6.7.5, and links to dependency diagrams
     provided in Section 9.</p>
     <p>While the [[?AV1]] and VP9 [[?VP9]] specifications support all the modes
     defined in the table, other codec specifications do not. For example, VP8
     [[?RFC6386]] only supports temporal scalability (e.g. "L1T2", "L1T3"); H.264/SVC
     [[?RFC6190]], which supports both temporal and spatial scalability, only permits
     transport of simulcast on distinct SSRCs, so that it does not support the
     "S" modes, where multiple encodings are transported on a single RTP stream.</p>
    <table class=simple>
      <tbody>
        <tr>
          <th>Scalability Mode Identifier</th>
          <th>Spatial Layers</th>
          <th>Resolution Ratio</th>
          <th>Temporal Layers</th>
          <th>Inter-layer dependency</th>
          <th>AV1 scalability_mode_idc</th>
        </tr>
      </tbody>
      <tbody>
        <tr>
          <td><a href="#L1T1*">"L1T1"</a></td>
          <td>1</td>
          <td></td>
          <td>1</td>
          <td></td>
          <td>N/A</td>
        </tr>
        <tr>
          <td><a href="#L1T2*">"L1T2"</a></td>
          <td>1</td>
          <td></td>
          <td>2</td>
          <td></td>
          <td>SCALABILITY_L1T2</td>
        </tr>
        <tr>
          <td><a href="#L1T3*">"L1T3"</a></td>
          <td>1</td>
          <td></td>
          <td>3</td>
          <td></td>
          <td>SCALABILITY_L1T3</td>
        </tr>
        <tr>
          <td><a href="#L2T1*">"L2T1"</a></td>
          <td>2</td>
          <td>2:1</td>
          <td>1</td>
          <td>Yes</td>
          <td>SCALABILITY_L2T1</td>
        </tr>
        <tr>
          <td><a href="#L2T2*">"L2T2"</a></td>
          <td>2</td>
          <td>2:1</td>
          <td>2</td>
          <td>Yes</td>
          <td>SCALABILITY_L2T2</td>
        </tr>
        <tr>
          <td><a href="#L2T3*">"L2T3"</a></td>
          <td>2</td>
          <td>2:1</td>
          <td>3</td>
          <td>Yes</td>
          <td>SCALABILITY_L2T3</td>
        </tr>
        <tr>
          <td><a href="#L3T1*">"L3T1"</a></td>
          <td>3</td>
          <td>2:1</td>
          <td>1</td>
          <td>Yes</td>
          <td>SCALABILITY_L3T1</td>
        </tr>
        <tr>
          <td><a href="#L3T2*">"L3T2"</a></td>
          <td>3</td>
          <td>2:1</td>
          <td>2</td>
          <td>Yes</td>
          <td>SCALABILITY_L3T2</td>
        </tr>
        <tr>
          <td><a href="#L3T3*">"L3T3"</a></td>
          <td>3</td>
          <td>2:1</td>
          <td>3</td>
          <td>Yes</td>
          <td>SCALABILITY_L3T3</td>
        </tr>
        <tr>
          <td><a href="#L2T1*">"L2T1h"</a></td>
          <td>2</td>
          <td>1.5:1</td>
          <td>1</td>
          <td>Yes</td>
          <td>SCALABILITY_L2T1h</td>
        </tr>
        <tr>
          <td><a href="#L2T2*">"L2T2h"</a></td>
          <td>2</td>
          <td>1.5:1</td>
          <td>2</td>
          <td>Yes</td>
          <td>SCALABILITY_L2T2h</td>
        </tr>
        <tr>
          <td><a href="#L2T3*">"L2T3h"</a></td>
          <td>2</td>
          <td>1.5:1</td>
          <td>3</td>
          <td>Yes</td>
          <td>SCALABILITY_L2T3h</td>
        </tr>
        <tr>
          <td><a href="#S2T1*">"S2T1"</a></td>
          <td>2</td>
          <td>2:1</td>
          <td>1</td>
          <td>No</td>
          <td>SCALABILITY_S2T1</td>
        </tr>
        <tr>
          <td><a href="#S2T2*">"S2T2"</a></td>
          <td>2</td>
          <td>2:1</td>
          <td>2</td>
          <td>No</td>
          <td>SCALABILITY_S2T2</td>
        </tr>
        <tr>
          <td><a href="#S2T3*">"S2T3"</a></td>
          <td>2</td>
          <td>2:1</td>
          <td>3</td>
          <td>No</td>
          <td>SCALABILITY_S2T3</td>
        </tr>
        <tr>
          <td><a href="#S2T1*">"S2T1h"</a></td>
          <td>2</td>
          <td>1.5:1</td>
          <td>1</td>
          <td>No</td>
          <td>SCALABILITY_S2T1h</td>
        </tr>
        <tr>
          <td><a href="#S2T2*">"S2T2h"</a></td>
          <td>2</td>
          <td>1.5:1</td>
          <td>2</td>
          <td>No</td>
          <td>SCALABILITY_S2T2h</td>
        </tr>
        <tr>
          <td><a href="#S2T3*">"S2T3h"</a></td>
          <td>2</td>
          <td>1.5:1</td>
          <td>3</td>
          <td>No</td>
          <td>SCALABILITY_S2T3h</td>
        </tr>
        <tr>
          <td><a href="#S3T1*">"S3T1"</a></td>
          <td>3</td>
          <td>2:1</td>
          <td>1</td>
          <td>No</td>
          <td>SCALABILITY_S3T1</td>
        </tr>
        <tr>
          <td><a href="#S3T2*">"S3T2"</a></td>
          <td>3</td>
          <td>2:1</td>
          <td>2</td>
          <td>No</td>
          <td>SCALABILITY_S3T2</td>
        </tr>
        <tr>
          <td><a href="#S3T3*">"S3T3"</a></td>
          <td>3</td>
          <td>2:1</td>
          <td>3</td>
          <td>No</td>
          <td>SCALABILITY_S3T3</td>
        </tr>
        <tr>
          <td><a href="#S3T1*">"S3T1h"</a></td>
          <td>3</td>
          <td>1.5:1</td>
          <td>1</td>
          <td>No</td>
          <td>SCALABILITY_S3T1h</td>
        </tr>
        <tr>
          <td><a href="#S3T2*">"S3T2h"</a></td>
          <td>3</td>
          <td>1.5:1</td>
          <td>2</td>
          <td>No</td>
          <td>SCALABILITY_S3T2h</td>
        </tr>
        <tr>
          <td><a href="#S3T3*">"S3T3h"</a></td>
          <td>3</td>
          <td>1.5:1</td>
          <td>3</td>
          <td>No</td>
          <td>SCALABILITY_S3T3h</td>
        </tr>
        <tr>
          <td><a href="#L2T2_KEY*">"L2T2_KEY"</a></td>
          <td>2</td>
          <td>2:1</td>
          <td>2</td>
          <td>Yes</td>
          <td>SCALABILITY_L3T2_KEY</td>
        </tr>
        <tr>
          <td><a href="#L2T2_KEY_SHIFT*">"L2T2_KEY_SHIFT"</a></td>
          <td>2</td>
          <td>2:1</td>
          <td>2</td>
          <td>Yes</td>
          <td>SCALABILITY_L3T2_KEY_SHIFT</td>
        </tr>
        <tr>
          <td><a href="#L2T3_KEY*">"L2T3_KEY"</a></td>
          <td>2</td>
          <td>2:1</td>
          <td>3</td>
          <td>Yes</td>
          <td>SCALABILITY_L3T3_KEY</td>
        </tr>
        <tr>
          <td><a href="#L2T3_KEY_SHIFT*">"L2T3_KEY_SHIFT"</a></td>
          <td>2</td>
          <td>2:1</td>
          <td>3</td>
          <td>Yes</td>
          <td>SCALABILITY_L3T3_KEY_SHIFT</td>
        </tr>
        <tr>
          <td><a href="#L3T2_KEY*">"L3T2_KEY"</a></td>
          <td>3</td>
          <td>2:1</td>
          <td>2</td>
          <td>Yes</td>
          <td>SCALABILITY_L4T5_KEY</td>
        </tr>
        <tr>
          <td><a href="#L3T2_KEY_SHIFT*">"L3T2_KEY_SHIFT"</a></td>
          <td>3</td>
          <td>2:1</td>
          <td>2</td>
          <td>Yes</td>
          <td>SCALABILITY_L4T5_KEY_SHIFT</td>
        </tr>
        <tr>
          <td><a href="#L3T3_KEY*">"L3T3_KEY"</a></td>
          <td>3</td>
          <td>2:1</td>
          <td>3</td>
          <td>Yes</td>
          <td>SCALABILITY_L4T7_KEY</td>
        </tr>
        <tr>
          <td><a href="#L3T3_KEY_SHIFT*">"L3T3_KEY_SHIFT"</a></td>
          <td>3</td>
          <td>2:1</td>
          <td>3</td>
          <td>Yes</td>
          <td>SCALABILITY_L4T7_KEY_SHIFT</td>
        </tr>
      </tbody>
    </table>
    <section id="addingmodes*">
      <h3>Guidelines for addition of {{RTCRtpEncodingParameters/scalabilityMode}} values</h3>
      <p>When proposing a {{RTCRtpEncodingParameters/scalabilityMode}} value, the following principles should be followed:</p>
        <ol>
          <li>
            The proposed {{RTCRtpEncodingParameters/scalabilityMode}} MUST define entries to the table in
            Section 6, including values for the Scalabilty Mode Identifier, spatial and
            temporal layers, Resolution Ratio, Inter-layer dependency and the corresponding
            AV1 scalability_mode_idc value (if assigned).
          </li>
          <li>
            The Scalability Mode Identifier SHOULD be consistent with the existing naming scheme, which
            utilizes <code>L<var>x</var>T<var>y</var></code> to denote a {{RTCRtpEncodingParameters/scalabilityMode}} with <var>x</var>
            spatial layers using a 2:1 resolution ratio and <var>y</var> temporal layers.
            <code>L<var>x</var>T<var>y</var>h</code> denotes <var>x</var> spatial layers with a 1.5:1 resolution ratio and
            <var>y</var> temporal layers. <code>S<var>x</var>T<var>y</var></code> denotes a {{RTCRtpEncodingParameters/scalabilityMode}}
            with <var>x</var> simulcast encodings with a 2:1 resolution ratio, with each
            simulcast encoding containing <var>y</var> temporal layers. <code>S<var>x</var>T<var>y</var>h</code> denotes
            a 1.5:1 resolution ratio. <code>L<var>x</var>T<var>y</var>_KEY</code> denotes a {{RTCRtpEncodingParameters/scalabilityMode}}
            with <var>x</var> spatial layers using a 2:1 resolution ratio and <var>y</var> temporal layers in which spatial layers only
            depend on lower spatial layers at a key frame. <code>L<var>x</var>T<var>y</var>_KEY_SHIFT</code> modes denotes a
            {{RTCRtpEncodingParameters/scalabilityMode}} with <var>x</var> spatial layers using a 2:1 resolution ratio and
            <var>y</var> temporal layers in which spatial layers only depend on lower spatial layers at a key frame and subsequent
            frames have their temporal identifier shifted upward.
          </li>
          <li>
            A dependency diagram MUST be supplied, in the format provided in Section 9.
          </li>         
        </ol>
    </section>
  </section>
  <section id="rtcrtpencodingparameters-example*">
      <h3>Examples</h3>
        <section id="simulcasttemporal-example*" class="informative">
          <h4>Spatial Simulcast and Temporal Scalability</h4>
          <p>This example extends [[WEBRTC]] Section 7.1 (Example 1) to demonstrate sending three spatial simulcast layers each with three temporal layers,
            using an SSRC and RID for each simulcast layer. Only the "sendEncodings" attribute is changed from the original example.</p>
          <pre class="example highlight">
const signaling = new SignalingChannel(); // handles JSON.stringify/parse
const constraints = {audio: true, video: true};
const configuration = {'iceServers': [{'urls': 'stun:stun.example.org'}]};
let pc;

// call start() to initiate
async function start() {
  pc = new RTCPeerConnection(configuration);

  // let the "negotiationneeded" event trigger offer generation
  pc.onnegotiationneeded = async () => {
    try {
      await pc.setLocalDescription();
      // send the offer to the other peer
      signaling.send({description: pc.localDescription});
    } catch (err) {
      console.error(err);
    }
  };

  try {
    // get a local stream, show it in a self-view and add it to be sent
    const stream = await navigator.mediaDevices.getUserMedia(constraints);
    selfView.srcObject = stream;
    pc.addTransceiver(stream.getAudioTracks()[0], {direction: 'sendonly'});
    pc.addTransceiver(stream.getVideoTracks()[0], {
      direction: 'sendonly',
      sendEncodings: [
        {rid: 'q', scaleResolutionDownBy: 4.0, scalabilityMode: 'L1T3'}
        {rid: 'h', scaleResolutionDownBy: 2.0, scalabilityMode: 'L1T3'},
        {rid: 'f', scalabilityMode: 'L1T3'},
      ]    
    });
  } catch (err) {
    console.error(err);
  }
}

signaling.onmessage = async ({data: {description, candidate}}) => {
  try {
    if (description) {
      await pc.setRemoteDescription(description);
      // if we got an offer, we need to reply with an answer
      if (description.type == 'offer') {
        await pc.setLocalDescription();
        signaling.send({description: pc.localDescription});
      }
    } else if (candidate) {
      await pc.addIceCandidate(candidate);
    }
  } catch (err) {
    console.error(err);
  }
};
</pre>
           <p> This is an example with two spatial layers (with a 2:1 ratio) and three temporal layers.</p> 
          <pre class="example highlight">
let sendEncodings = [
  {scalabilityMode: 'L2T3'}
];
</pre>
           <p> This is an example with three spatial simulcast layers each with three temporal layers on a single SSRC.</p> 
          <pre class="example highlight">
let sendEncodings = [
  {scalabilityMode: 'S3T3'}
]    
</pre>
    </section>
    <section id="sender-getcapabilities-example*" class="informative">
       <h4>SVC Encoder Capabilities</h4>
      <p>This is an example of {{RTCRtpSender}}.<code>getCapabilities}}('video').codecs[]</code> returned by a
        browser implementing [[WEBRTC]]. Only the <code>scalabilityModes</code> attribute is defined in this specification.</p>
       <pre class="example highlight">
  "codecs": [
    {
      "clockRate": 90000,
      "mimeType": "video/VP8",
      "scalabilityModes": [
        "L1T2",
        "L1T3"
      ]
    },
    {
      "clockRate": 90000,
      "mimeType": "video/rtx",
      "sdpFmtpLine": "apt=96"
    },
    {
      "clockRate": 90000,
      "mimeType": "video/VP9",
      "scalabilityModes": [
        "L1T2",
        "L1T3",
        "L2T1",
        "L2T2",
        "L2T3",
        "L3T1",
        "L3T2",
        "L3T3",
        "L1T2h",
        "L1T3h",
        "L2T1h",
        "L2T2h",
        "L2T3h"
      ]
    },
    {
      "clockRate": 90000,
      "mimeType": "video/rtx",
      "sdpFmtpLine": "apt=98"
    },
    {
      "clockRate": 90000,
      "mimeType": "video/H264",
      "sdpFmtpLine": "packetization-mode=1;profile-level-id=42001f;level-asymmetry-allowed=1"
    },
    {
      "clockRate": 90000,
      "mimeType": "video/rtx",
      "sdpFmtpLine": "apt=100"
    },
    {
      "clockRate": 90000,
      "mimeType": "video/H264",
      "sdpFmtpLine": "packetization-mode=0;profile-level-id=42001f;level-asymmetry-allowed=1"
    },
    {
      "clockRate": 90000,
      "mimeType": "video/rtx",
      "sdpFmtpLine": "apt=102"
    },
    {
      "clockRate": 90000,
      "mimeType": "video/H264",
      "sdpFmtpLine": "level-asymmetry-allowed=1;profile-level-id=42e01f;packetization-mode=1"
    },
    {
      "clockRate": 90000,
      "mimeType": "video/rtx",
      "sdpFmtpLine": "apt=104"
    },
    {
      "clockRate": 90000,
      "mimeType": "video/H264",
      "sdpFmtpLine": "level-asymmetry-allowed=1;profile-level-id=42e01f;packetization-mode=0"
    },
    {
      "clockRate": 90000,
      "mimeType": "video/rtx",
      "sdpFmtpLine": "apt=106"
    },
    {
      "clockRate": 90000,
      "mimeType": "video/H264",
      "sdpFmtpLine": "level-asymmetry-allowed=1;profile-level-id=4d0032;packetization-mode=1"
    },
    {
      "clockRate": 90000,
      "mimeType": "video/rtx",
      "sdpFmtpLine": "apt=108"
    },
    {
      "clockRate": 90000,
      "mimeType": "video/H264",
      "sdpFmtpLine": "level-asymmetry-allowed=1;profile-level-id=640032;packetization-mode=1"
    },
    {
      "clockRate": 90000,
      "mimeType": "video/rtx",
      "sdpFmtpLine": "apt=110"
    },
    {
      "clockRate": 90000,
      "mimeType": "video/red"
    },
    {
      "clockRate": 90000,
      "mimeType": "video/rtx",
      "sdpFmtpLine": "apt=112"
    },
    {
      "clockRate": 90000,
      "mimeType": "video/ulpfec"
    },
    {
      "clockRate": 90000,
      "mimeType": "video/AV1",
      "scalabilityModes": [
        "L1T2",
        "L1T3",
        "L2T1",
        "L2T2",
        "L2T3",
        "L3T1",
        "L3T2",
        "L3T3",
        "L1T2h",
        "L1T3h",
        "L2T1h",
        "L2T2h",
        "L2T3h",
        "S2T1",
        "S2T2",
        "S2T3",
        "S3T1",
        "S3T2",
        "S3T3",
        "S2T1h",
        "S2T2h",
        "S2T3h",
        "S3T1h",
        "S3T2h",
        "S3T3h"
      ]
    },
    {
      "clockRate": 90000,
      "mimeType": "video/rtx",
      "sdpFmtpLine": "apt=113"
    }
]
</pre>
    </section>
        <section id="sfm-getcapabilities-example*" class="informative" >
       <h4>SFM Capabilities</h4>
       <p>This is an example of {{RTCRtpReceiver}}.<code>getCapabilities('video').codecs[]</code>
       returned by an SFM that only supports forwarding of VP8, VP9 and AV1 temporal
       scalability modes.</p>
       <pre class="example highlight">
 "codecs": [
    {
      "clockRate": 90000,
      "mimeType": "video/VP8",
      "scalabilityModes": [
        "L1T2",
        "L1T3"
      ]
    },
    {
      "clockRate": 90000,
      "mimeType": "video/VP9",
      "scalabilityModes": [
        "L1T2",
        "L1T3",
        "L1T2h",
        "L1T3h"
      ]
    },
    {
      "clockRate": 90000,
      "mimeType": "video/AV1",
      "scalabilityModes": [
        "L1T2",
        "L1T3",
        "L1T2h",
        "L1T3h"
      ]
    }
]
</pre>
    </section>
    <section id="receiver-getcapabilities-example*" class="informative">
       <h4>SVC Decoder Capabilities</h4>
       <p>This is an example of {{RTCRtpReceiver}}.<code>getCapabilities('video').codecs[]</code>
         returned by a browser that can support all scalability modes of the VP8 and VP9 codecs.</p>
       <pre class="example highlight">
  "codecs": [
    { 
      "clockRate": 90000,
      "mimeType": "video/VP8"
    },
    { 
      "clockRate": 90000,
      "mimeType": "video/rtx",
      "sdpFmtpLine": "apt=96"
    },
    { 
      "clockRate": 90000,
      "mimeType": "video/VP9"
    },
    {
      "clockRate": 90000,
      "mimeType": "video/rtx",
      "sdpFmtpLine": "apt=98"
    },
    {
      "clockRate": 90000,
      "mimeType": "video/H264",
      "sdpFmtpLine": "packetization-mode=1;profile-level-id=42001f;level-asymmetry-allowed=1"
    },

    ...
]
</pre>
    </section>
    </section>
  <section class="informative"  id="privacy-security">
    <h2>Privacy and Security Considerations</h2>
    <p>This section is non-normative; it specifies no new behaviour, but
    instead summarizes information already present in other parts of the
    specification. WebRTC protocol security considerations are described
    in [[RTCWEB-SECURITY-ARCH]] and the security and privacy considerations
    for the WebRTC APIs are described in [[WEBRTC]] Section 13.</p>
    <section>
      <h2>Persistent information</h2>
      <p>The WebRTC API exposes information about the underlying media system
      via the {{RTCRtpSender.getCapabilities()}} and
      {{RTCRtpReceiver}}<code>.getCapabilities</code> methods, including
      detailed and ordered information about the codecs that the system is able
      to produce and consume. The WebRTC-SVC extension adds the
      {{RTCRtpCodecCapability/scalabilityModes}} supported by the {{RTCRtpSender}}
      to that information, which is persistent across time, therefore increasing
      the fingerprint surface. Since for SVC codecs implemented in WebRTC browsers
      compliant decoders are required to be able to decode all scalability modes,
      additional information is not provided relating to the {{RTCRtpReceiver}}.</p>
      <p>Since for SVC codecs implemented in WebRTC the use of scalable coding tools
      is not negotiated and is independent of the supported profiles, and since SVC
      is rarely supported in hardware encoders, knowledge of the
      {{RTCRtpCodecCapability/scalabilityModes}} supported by the {{RTCRtpSender}}
      does not provide additional information on the underlying hardware.
      However, since browsers may differ in their support for SVC modes, the supported
      {{RTCRtpCodecCapability/scalabilityModes}} may permit differentiation
      between browsers. This additional fingerprint surface is expected to decrease
      over time as this specification is more widely implemented.</p>
    </section>
  </section>
  <section id="dependencydiagrams*">
   <h2>Scalability Mode Dependency Diagrams</h2>
   <p>Dependency diagrams for the scability modes defined in this specification are provided below.</p>
   <section id="L1T1*">
   <h3>L1T1</h3>
          <figure>
            <img alt="L1T1: a single layer" src=
            "images/L1T1.svg" style="width:75%">
            <figcaption>
              L1T1: 1-layer encoding
            </figcaption>
          </figure>
   </section>
   <section id="L1T2*">
   <h3>L1T2 and L1T2h</h3>
          <figure>
            <img alt="L1T2 and L1T2h: 2-layer temporal scalability encoding" src=
            "images/L1T2.svg" style="width:75%">
            <figcaption>
              L1T2 and L1T2h: 1-layer spatial and 2-layer temporal scalability encoding
            </figcaption>
          </figure>
   </section>
   <section id="L1T3*">
   <h3>L1T3 and L1T3h</h3>
          <figure>
            <img alt="L1T3 and L1T3h: 3-layer temporal scalability encoding" src=
            "images/L1T3.svg" style="width:75%">
            <figcaption>
              L1T3 and L1T3h: 1-layer spatial and 3-layer temporal scalability encoding
            </figcaption>
          </figure>
   </section>
   <section id="L2T1*">
   <h3>L2T1 and L2T1h</h3>
          <figure>
            <img alt="L2T1 and L2T1h: 2-layer spatial and 1-layer temporal scalability encoding" src=
            "images/L2T1.svg" style="width:75%">
            <figcaption>
              L2T1 and L2T1h: 2-layer spatial and 1-layer temporal scalability encoding
            </figcaption>
          </figure>
   </section>
   <section id="L2T1_KEY*">
   <h3>L2T1_KEY</h3>
          <figure>
            <img alt="L2T1_KEY: 2-layer spatial and 1-layer temporal scalability K-SVC encoding" src=
            "images/L2T1_KEY.svg" style="width:75%">
            <figcaption>
              L2T1_KEY: 2-layer spatial and 1-layer temporal scalability K-SVC encoding
            </figcaption>
          </figure>
   </section>
   <section id="L2T2*">
   <h3>L2T2 and L2T2h</h3>
          <figure>
            <img alt="L2T2 and L2T2h: 2-layer spatial and 2-layer temporal scalability encoding" src=
            "images/L2T2.svg" style="width:75%">
            <figcaption>
              L2T2 and L2T2h: 2-layer spatial and 2-layer temporal scalability encoding
            </figcaption>
          </figure>
   </section>
   <section id="L2T2_KEY*">
   <h3>L2T2_KEY</h3>
          <figure>
            <img alt="L2T2_KEY: 2-layer spatial and 2-layer temporal scalability K-SVC encoding" src=
            "images/L2T2_KEY.svg" style="width:75%">
            <figcaption>
              L2T2_KEY: 2-layer spatial and 2-layer temporal scalability K-SVC encoding
            </figcaption>
          </figure>
   </section>
   <section id="L2T2_KEY_SHIFT*">
   <h3>L2T2_KEY_SHIFT</h3>
          <figure>
            <img alt="L2T2_KEY_SHIFT: 2-layer spatial and 2-layer temporal scalability K-SVC shifted encoding with temporal shift" src=
            "images/L2T2_KEY_SHIFT.svg" style="width:75%">
            <figcaption>
              L2T2_KEY_SHIFT: 2-layer spatial and 2-layer temporal scalability K-SVC encoding with temporal shift
            </figcaption>
          </figure>
   </section>
   <section id="L2T3*">
   <h3>L2T3 and L2T3h</h3>
          <figure>
            <img alt="L2T3 and L2T3h: 2-layer spatial and 3-layer temporal scalability encoding" src=
            "images/L2T3.svg" style="width:75%">
            <figcaption>
              L2T3 and L2T3h: 2-layer spatial and 3-layer temporal scalability encoding
            </figcaption>
          </figure>
   </section>
   <section id="L2T3_KEY*">
   <h3>L2T3_KEY</h3>
          <figure>
            <img alt="L2T3_KEY: 2-layer spatial and 3-layer temporal scalability K-SVC encoding" src=
            "images/L2T3_KEY.svg" style="width:75%">
            <figcaption>
              L2T3_KEY: 2-layer spatial and 3-layer temporal scalability K-SVC encoding
            </figcaption>
          </figure>
   </section>
   <section id="L2T3_KEY_SHIFT*">
   <h3>L2T3_KEY_SHIFT</h3>
          <figure>
            <img alt="L2T3_KEY_SHIFT: 2-layer spatial and 3-layer temporal scalability K-SVC shifted encoding with temporal shift" src=
            "images/L2T3_KEY_SHIFT.svg" style="width:75%">
            <figcaption>
              L2T3_KEY_SHIFT: 2-layer spatial and 3-layer temporal scalability K-SVC encoding with temporal shift
            </figcaption>
          </figure>
   </section>
   <section id="L3T1*">
   <h3>L3T1 and L3T1h</h3>
          <figure>
            <img alt="L3T1 and L3T1h: 3-layer spatial and 1-layer temporal scalability encoding" src=
            "images/L3T1.svg" style="width:75%">
            <figcaption>
              L3T1 and L3T1h: 3-layer spatial and 1-layer temporal scalability encoding
            </figcaption>
          </figure>
   </section>
   <section id="L3T1_KEY*">
   <h3>L3T1_KEY</h3>
          <figure>
            <img alt="L3T1_KEY: 3-layer spatial and 1-layer temporal scalability K-SVC encoding" src=
            "images/L3T1_KEY.svg" style="width:75%">
            <figcaption>
              L3T1_KEY: 3-layer spatial and 1-layer temporal scalability K-SVC encoding
            </figcaption>
          </figure>
   </section>
   <section id="L3T2*">
   <h3>L3T2 and L3T2h</h3>
          <figure>
            <img alt="L3T2 and L3T2h: 3-layer spatial and 2-layer temporal scalability encoding" src=
            "images/L3T2.svg" style="width:75%">
            <figcaption>
              L3T2 and L3T2h: 3-layer spatial and 2-layer temporal scalability encoding
            </figcaption>
          </figure>
   </section>
   <section id="L3T2_KEY*">
   <h3>L3T2_KEY</h3>
          <figure>
            <img alt="L3T2_KEY: 3-layer spatial and 2-layer temporal scalability K-SVC encoding" src=
            "images/L3T2_KEY.svg" style="width:75%">
            <figcaption>
              L3T2_KEY: 3-layer spatial and 2-layer temporal scalability K-SVC encoding
            </figcaption>
          </figure>
   </section>
   <section id="L3T2_KEY_SHIFT*">
   <h3>L3T2_KEY_SHIFT</h3>
          <figure>
            <img alt="L3T2_KEY_SHIFT: 3-layer spatial and 2-layer temporal scalability K-SVC with temporal shift" src=
            "images/L3T2_KEY_SHIFT.svg" style="width:75%">
            <figcaption>
              L3T2_KEY_SHIFT: 3-layer spatial and 2-layer temporal scalability K-SVC with temporal shift
            </figcaption>
          </figure>
   </section>
   <section id="L3T3*">
   <h3>L3T3 and L3T3h</h3>
          <figure>
            <img alt="L3T3 and L3T3h: 3-layer spatial and 3-layer temporal scalability encoding" src=
            "images/L3T3.svg" style="width:75%">
            <figcaption>
              L3T3 and L3T3h: 3-layer spatial and 3-layer temporal scalability encoding
            </figcaption>
          </figure>
   </section>
   <section id="L3T3_KEY*">
   <h3>L3T3_KEY</h3>
          <figure>
            <img alt="L3T3_KEY: 3-layer spatial and 3-layer temporal scalability K-SVC encoding" src=
            "images/L3T3_KEY.svg" style="width:75%">
            <figcaption>
              L3T3_KEY: 3-layer spatial and 3-layer temporal scalability K-SVC encoding
            </figcaption>
          </figure>
   </section>
   <section id="L3T3_KEY_SHIFT*">
   <h3>L3T3_KEY_SHIFT</h3>
          <figure>
            <img alt="L3T3_KEY_SHIFT: 3-layer spatial and 3-layer temporal scalability K-SVC with temporal shift" src=
            "images/L3T3_KEY_SHIFT.svg" style="width:75%">
            <figcaption>
              L3T3_KEY_SHIFT: 3-layer spatial and 3-layer temporal scalability K-SVC with temporal shift
            </figcaption>
          </figure>
   </section>
   <section id="S2T1*">
   <h3>S2T1 and S2T1h</h3>
          <figure>
            <img alt="S2T1 and S2T1h: 2-layer spatial simulcast encoding" src=
            "images/S2T1.svg" style="width:75%">
            <figcaption>
              S2T1 and S2T1h: 2-layer spatial simulcast encoding
            </figcaption>
          </figure>
   </section>
   <section id="S2T2*">
   <h3>S2T2 and S2T2h</h3>
          <figure>
            <img alt="S2T2 and S2T2h: 2-layer spatial simulcast and 2-layer temporal scalability encoding" src=
            "images/S2T2.svg" style="width:75%">
            <figcaption>
              S2T2 and S2T2h: 2-layer spatial simulcast and 2-layer temporal scalability encoding
            </figcaption>
          </figure>
   </section>
   <section id="S2T3*">
   <h3>S2T3 and S2T3h</h3>
          <figure>
            <img alt="S2T3 and S2T3h: 2-layer spatial simulcast and 3-layer temporal scalability encoding" src=
            "images/S2T3.svg" style="width:75%">
            <figcaption>
              S2T3 and S2T3h: 2-layer spatial simulcast and 3-layer temporal scalability encoding
            </figcaption>
          </figure>
   </section>
   <section id="S3T1*">
   <h3>S3T1 and S3T1h</h3>
          <figure>
            <img alt="S3T1 and S3T1h: 3-layer spatial simulcast encoding" src=
            "images/S3T1.svg" style="width:75%">
            <figcaption>
              S3T1 and S3T1h: 3-layer spatial simulcast encoding
            </figcaption>
          </figure>
   </section>
   <section id="S3T2*">
   <h3>S3T2 and S3T2h</h3>
          <figure>
            <img alt="S3T2 and S3T2h: 3-layer spatial simulcast and 2-layer temporal scalability encoding" src=
            "images/S3T2.svg" style="width:75%">
            <figcaption>
              S3T2 and S3T2h: 3-layer spatial simulcast and 2-layer temporal scalability encoding
            </figcaption>
          </figure>
   </section>
   <section id="S3T3*">
   <h3>S3T3 and S3T3h</h3>
          <figure>
            <img alt="S3T3 and S3T3h: 3-layer spatial simulcast and 3-layer temporal scalability encoding" src=
            "images/S3T3.svg" style="width:75%">
            <figcaption>
              S3T3 and S3T3h: 3-layer spatial simulcast and 3-layer temporal scalability encoding
            </figcaption>
          </figure>
   </section>
 </section>
 <section class="appendix">
   <h2>Acknowledgements</h2>
      <p>
        The editors wish to thank Robin Raymond, Michael Horowitz, Harald Alvestrand,
        Chris Cunningham and Danil Chapovalov for their contributions to this
        specification, which represents an evolution of the ORTC API
        developed in the <a href="https://www.w3.org/community/ortc/">W3C ORTC
        CG</a>.
      </p>
  </section>
</body>
</html>
